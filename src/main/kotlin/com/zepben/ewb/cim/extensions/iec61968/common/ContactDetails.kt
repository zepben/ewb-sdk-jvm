/*
 * Copyright 2025 Zeppelin Bend Pty Ltd
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package com.zepben.ewb.cim.extensions.iec61968.common

import com.zepben.ewb.cim.extensions.ZBEX
import com.zepben.ewb.cim.iec61968.common.ElectronicAddress
import com.zepben.ewb.cim.iec61968.common.StreetAddress
import com.zepben.ewb.cim.iec61968.common.TelephoneNumber
import com.zepben.ewb.services.common.extensions.asUnmodifiable
import com.zepben.ewb.testing.ListWrapper
import com.zepben.ewb.testing.MRIDListWrapper
import java.util.*

/**
 * The details required to contact a person or company.
 *
 * @property id [ZBEX] The identifier for this contact, could be autogenerated.
 * @property contactAddress [ZBEX] Contact address, potentially different than 'streetAddress' (e.g., another city).
 * @property contactType [ZBEX] The type of contact, e.g. Account Owner.
 * @property firstName [ZBEX] First name of the contact.
 * @property lastName [ZBEX] Last name of the contact.
 * @property preferredContactMethod [ZBEX] The preferred contact method for this contact.
 * @property isPrimary [ZBEX] Whether this contact is a primary contact.
 * @property businessName [ZBEX] The business name of this contact.
 * @property phoneNumbers [ZBEX] Phone numbers.
 * @property electronicAddresses [ZBEX] Electronic addresses.
 */
@ZBEX
class ContactDetails @JvmOverloads constructor(id: String = "") {

    @ZBEX
    val id: String = id.ifEmpty { UUID.randomUUID().toString() }

    @ZBEX
    var contactAddress: StreetAddress? = null

    @ZBEX
    var contactType: String? = null

    @ZBEX
    var firstName: String? = null

    @ZBEX
    var lastName: String? = null

    @ZBEX
    var preferredContactMethod: ContactMethodType = ContactMethodType.UNKNOWN

    @ZBEX
    var isPrimary: Boolean? = null

    @ZBEX
    var businessName: String? = null

    @ZBEX
    private var _phoneNumbers: MutableList<TelephoneNumber>? = null

    @ZBEX
    private var _electronicAddresses: MutableList<ElectronicAddress>? = null

    val phoneNumbers: ListWrapper<TelephoneNumber>
        get() = ListWrapper(
            getter = { _phoneNumbers },
            setter = { _phoneNumbers = it })

    @Deprecated("BOILERPLATE: Use phoneNumbers.size instead")
    fun numPhoneNumbers(): Int = phoneNumbers.size

    /**
     * Add an [TelephoneNumber] to this [ContactDetails].
     *
     * @param phoneNumber The [TelephoneNumber] to add.
     * @return This [ContactDetails] for fluent use.
     */
    fun addPhoneNumber(phoneNumber: TelephoneNumber): ContactDetails {
        _phoneNumbers = _phoneNumbers ?: mutableListOf()
        _phoneNumbers!!.add(phoneNumber)

        return this
    }

    @Deprecated("BOILERPLATE: Use phoneNumbers.remove(phoneNumber) instead")
    fun removePhoneNumber(phoneNumber: TelephoneNumber): Boolean = phoneNumbers.remove(phoneNumber)

    @Deprecated("BOILERPLATE: Use phoneNumbers.clear() instead")
    fun clearPhoneNumbers(): ContactDetails {
        phoneNumbers.clear()
        return this
    }

    val electronicAddresses: ListWrapper<ElectronicAddress>
        get() = ListWrapper(
            getter = { _electronicAddresses },
            setter = { _electronicAddresses = it })

    @Deprecated("BOILERPLATE: Use electronicAddresses.size instead")
    fun numElectronicAddresses(): Int = electronicAddresses.size

    /**
     * Add an [ElectronicAddress] to this [ContactDetails].
     *
     * @param electronicAddress The [ElectronicAddress] to add.
     * @return This [ContactDetails] for fluent use.
     */
    fun addElectronicAddress(electronicAddress: ElectronicAddress): ContactDetails {
        _electronicAddresses = _electronicAddresses ?: mutableListOf()
        _electronicAddresses!!.add(electronicAddress)

        return this
    }

    @Deprecated("BOILERPLATE: Use electronicAddresses.remove(electronicAddress) instead")
    fun removeElectronicAddress(electronicAddress: ElectronicAddress): Boolean = electronicAddresses.remove(electronicAddress)

    @Deprecated("BOILERPLATE: Use electronicAddresses.clear() instead")
    fun clearElectronicAddresses(): ContactDetails {
        electronicAddresses.clear()
        return this
    }

    override fun equals(other: Any?): Boolean {
        //
        // NOTE: We implement the equals to allow us to compare the entire `ContactDetails` as a value. We do this since it isn't an
        //       `IdentifiedObject`, so our other helpers don't support it.
        //
        return when {
            this === other -> true
            (other as? ContactDetails) == null -> false
            isPrimary != other.isPrimary -> false
            id != other.id -> false
            contactAddress != other.contactAddress -> false
            contactType != other.contactType -> false
            firstName != other.firstName -> false
            lastName != other.lastName -> false
            preferredContactMethod != other.preferredContactMethod -> false
            businessName != other.businessName -> false
            _phoneNumbers != other._phoneNumbers -> false
            _electronicAddresses != other._electronicAddresses -> false
            else -> true
        }
    }

    override fun hashCode(): Int {
        var result = isPrimary?.hashCode() ?: 0

        result = 31 * result + id.hashCode()
        result = 31 * result + (contactAddress?.hashCode() ?: 0)
        result = 31 * result + (contactType?.hashCode() ?: 0)
        result = 31 * result + (firstName?.hashCode() ?: 0)
        result = 31 * result + (lastName?.hashCode() ?: 0)
        result = 31 * result + preferredContactMethod.hashCode()
        result = 31 * result + (businessName?.hashCode() ?: 0)
        result = 31 * result + (_phoneNumbers?.hashCode() ?: 0)
        result = 31 * result + (_electronicAddresses?.hashCode() ?: 0)

        return result
    }


}
